Strategy Pattern
1. Strategy 패턴이란?
알고리즘(행동)을 인터페이스로 분리하고, 실행 중에 원하는 알고리즘으로 교체할 수 있게 만드는 디자인 패턴.

즉,
실행할 알고리즘(전략)을 외부에서 주입받고
런타임에 얼마든지 바꿀 수 있으며
공통 기능은 “Context”에서 실행
하는 구조를 만드는 것이다.
예를 들어 정렬 기능을 만든다고 하면:
오름차순 정렬
내림차순 정렬
길이 기준 정렬

이 모두 “정렬”이지만 내부 알고리즘만 다르다.
이걸 각각 분리해서 “전략(Strategy)”로 만든 뒤,
필요할 때마다 바꿔 끼우는 방식이 Strategy Pattern이다.

2. 왜 필요한가?
✔ 1) 알고리즘을 유연하게 교체 가능
코드를 수정하지 않고 전략만 바꿔 끼우면 동작이 달라짐.
✔ 2) if-else / switch 문 제거
전략이 많아지면 보통 이렇게 된다:
if(type == "ASC") { ... }
else if(type == "DESC") { ... }
else if(type == "Length") { ... }
→ 조건문 난무
→ 유지보수 지옥
Strategy에서는 이걸 이렇게 함:
sorter.SetStrategy(new AscendingSorter());
✔ 3) 새로운 알고리즘 추가가 쉬움(Open-Closed Principle)
전략 클래스를 하나 추가하면 끝.
기존 코드는 건드릴 필요 없음.

3. 분야 예시
WMS/MES	재고 계산 방식, 작업 우선순위, 경로 계산 방식
결제/요금 정책	카드/포인트/쿠폰 할인 정책 변경
정렬/필터링 로직	검색 조건 변경, UI 필터
인증 방식	OAuth / JWT / Basic 인증 전환
압축/암호화	ZIP, AES, RSA 선택

4. 장점 (Advantages)
✔ 알고리즘 교체가 자유롭다
Context 코드는 수정하지 않고 전략만 바꾸면 됨.
✔ 조건문 제거 → 코드 깔끔
if-else / switch로 알고리즘 분기하는 문제 해결.
✔ 변경에 강함 (OCP 준수)
새 전략 추가 시 기존 코드 손대지 않음.
✔ 테스트 용이
전략별로 단위 테스트 가능.

5. 단점 (Disadvantages)
클래스 수가 증가
전략이 5개면 클래스도 5개 생김.
전략 교체를 개발자가 직접 관리해야 함
SetStrategy를 잘못하면 잘못된 알고리즘이 적용될 위험 있음.
단순한 로직에는 오히려 과한 설계
작은 기능에는 굳이 쓸 필요 없음.

